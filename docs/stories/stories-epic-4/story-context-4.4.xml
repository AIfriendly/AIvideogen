<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context XML for Story 4.4: Clip Selection Mechanism & State Management
  Generated by SM Agent for Dev Agent implementation
  Date: 2025-11-21
  Epic: 4 - Visual Curation Interface
-->
<story-context>
  <!-- ============================================== -->
  <!-- STORY DEFINITION -->
  <!-- ============================================== -->
  <story id="4.4" status="Ready">
    <title>Clip Selection Mechanism &amp; State Management</title>
    <goal>Allow users to select exactly one video clip per scene and persist selections</goal>
    <epic>Epic 4 - Visual Curation Interface</epic>

    <dependencies>
      <dependency status="DONE">Story 4.2 (Visual Suggestions Display &amp; Gallery)</dependency>
      <dependency status="DONE">Story 4.3 (Video Preview &amp; Playback Functionality)</dependency>
      <dependency status="DONE">Epic 3 Story 3.5 (Visual Suggestions Database &amp; Workflow Integration)</dependency>
    </dependencies>

    <user-story>
      As a user reviewing visual suggestions in the curation interface,
      I want to select one video clip per scene with clear visual feedback and have my selections automatically saved,
      so that I can curate my video assembly without losing my choices when navigating away or refreshing the page.
    </user-story>

    <acceptance-criteria>
      <criterion id="1">Clicking a suggestion card marks it as "Selected" with visual indicator (checkmark icon, indigo border, shadow glow)</criterion>
      <criterion id="2">Selecting a different clip for the same scene automatically deselects the previous one</criterion>
      <criterion id="3">Selection state persists during page session (stored in Zustand store with localStorage backup)</criterion>
      <criterion id="4">POST /api/projects/[id]/select-clip saves selection to database (scenes.selected_clip_id)</criterion>
      <criterion id="5">Selection count indicator displays at top of page: "Scenes Selected: 3/5"</criterion>
      <criterion id="6">Optimistic UI update (selection appears immediately, saved in background)</criterion>
      <criterion id="7">Error handling: if save fails, show toast notification and revert UI state</criterion>
      <criterion id="8">All scenes default to "No selection" state initially</criterion>
      <criterion id="9">Database migration adds selected_clip_id column to scenes table (foreign key to visual_suggestions)</criterion>
    </acceptance-criteria>
  </story>

  <!-- ============================================== -->
  <!-- FILES TO CREATE -->
  <!-- ============================================== -->
  <files-to-create>
    <file path="src/lib/stores/curation-store.ts" description="Zustand store for clip selection state management with localStorage persistence">
      <implementation-notes>
        - Follow pattern from existing project-store.ts
        - Use Map for O(1) sceneId lookups
        - Implement custom storage for Map serialization
        - Include saveClipSelection helper function for API calls
        - Handle error callbacks for UI reversion
      </implementation-notes>
    </file>

    <file path="src/app/api/projects/[id]/select-clip/route.ts" description="POST endpoint to save clip selection to database">
      <implementation-notes>
        - Follow pattern from existing scenes/route.ts and visual-suggestions/route.ts
        - Validate scene belongs to project
        - Validate suggestion belongs to scene
        - Update scenes.selected_clip_id column
        - Return standard response format
      </implementation-notes>
    </file>

    <file path="src/lib/db/migrations/006_add_selected_clip_id.ts" description="Database migration to add selected_clip_id column to scenes table">
      <implementation-notes>
        - Follow pattern from migrations 002 and 003
        - Use ALTER TABLE to add column
        - Create index on selected_clip_id for performance
        - Idempotency check before adding column
      </implementation-notes>
    </file>

    <file path="tests/stores/curation-store.test.ts" description="Unit tests for curation store">
      <implementation-notes>
        - Test selectClip adds selection to Map
        - Test selectClip replaces previous selection for same scene
        - Test clearSelection removes selection
        - Test isSceneComplete returns correct boolean
        - Test getSelectionCount returns accurate count
        - Test getAllSelected returns true when all scenes selected
        - Test localStorage persistence (serialize/deserialize Map)
        - Test reset clears all state
      </implementation-notes>
    </file>

    <file path="tests/api/select-clip.test.ts" description="API tests for select-clip endpoint">
      <implementation-notes>
        - Test POST returns 200 with valid sceneId and suggestionId
        - Test POST returns 400 for missing sceneId
        - Test POST returns 400 for invalid sceneId (not in project)
        - Test POST returns 409 for suggestionId not belonging to scene
        - Test database is updated with selected_clip_id
        - Test response format matches specification
      </implementation-notes>
    </file>
  </files-to-create>

  <!-- ============================================== -->
  <!-- FILES TO MODIFY -->
  <!-- ============================================== -->
  <files-to-modify>
    <file path="src/components/features/curation/SuggestionCard.tsx">
      <modifications>
        <modification description="Add isSelected and onSelect props to component interface">
          Add new props: isSelected?: boolean, onSelect?: () =&gt; void
        </modification>
        <modification description="Add visual selection indicators when isSelected=true">
          - Checkmark icon (Check from lucide-react) in top-right corner
          - Indigo border: border-indigo-500 border-2
          - Shadow glow: shadow-lg shadow-indigo-500/20
          - "Selected" badge at bottom of card
        </modification>
        <modification description="Separate selection click from preview click">
          - Card body click triggers onSelect
          - Preview button click (with stopPropagation) triggers onClick (preview)
        </modification>
      </modifications>
    </file>

    <file path="src/components/features/curation/VisualSuggestionGallery.tsx">
      <modifications>
        <modification description="Import and use useCurationStore hook">
          Get current selection state for scene from store
        </modification>
        <modification description="Pass isSelected and onSelect props to SuggestionCard">
          Determine if each suggestion is selected and handle selection
        </modification>
        <modification description="Implement handleSelectClip with toast notifications">
          Call store selectClip action and show success/error toasts
        </modification>
      </modifications>
    </file>

    <file path="src/app/projects/[id]/visual-curation/VisualCurationClient.tsx">
      <modifications>
        <modification description="Import and initialize useCurationStore">
          Set project ID and total scenes on mount
        </modification>
        <modification description="Add selection progress counter display">
          Show "Scenes Selected: X/Y" in header with CheckCircle when complete
        </modification>
        <modification description="Load existing selections from database on mount">
          Fetch scenes with selected_clip_id and populate store
        </modification>
      </modifications>
    </file>

    <file path="src/lib/db/queries.ts">
      <modifications>
        <modification description="Update Scene interface with selected_clip_id field">
          Add: selected_clip_id: string | null
        </modification>
        <modification description="Update getScenesByProjectId to return selected_clip_id">
          Include selected_clip_id in SELECT query
        </modification>
        <modification description="Add updateSceneSelectedClip function">
          Update scenes.selected_clip_id by scene ID
        </modification>
      </modifications>
    </file>

    <file path="src/lib/db/init.ts">
      <modifications>
        <modification description="Import and register new migration">
          Add 006_add_selected_clip_id to migrations array
        </modification>
      </modifications>
    </file>
  </files-to-modify>

  <!-- ============================================== -->
  <!-- EXISTING CODE ARTIFACTS -->
  <!-- ============================================== -->
  <existing-code>
    <!-- Project Store Pattern Reference -->
    <artifact name="project-store.ts" path="src/lib/stores/project-store.ts">
      <description>Reference Zustand store with localStorage persistence pattern</description>
      <code><![CDATA[
'use client';

import { create } from 'zustand';
import { persist } from 'zustand/middleware';

/**
 * Project interface
 */
export interface Project {
  id: string;
  name: string;
  topic: string | null;
  currentStep: string;
  lastActive: string; // ISO 8601 timestamp
  createdAt: string; // ISO 8601 timestamp
}

/**
 * Project state interface
 */
interface ProjectState {
  // State
  activeProjectId: string | null;
  projects: Project[];

  // Actions
  setActiveProject: (id: string) => void;
  loadProjects: (projects: Project[]) => void;
  addProject: (project: Project) => void;
  updateProject: (id: string, updates: Partial<Project>) => void;
  removeProject: (id: string) => void;
}

/**
 * Project store with localStorage persistence
 */
export const useProjectStore = create<ProjectState>()(
  persist(
    (set) => ({
      // Initial state
      activeProjectId: null,
      projects: [],

      /**
       * Set active project and update last_active timestamp via API
       */
      setActiveProject: (id) => {
        set({ activeProjectId: id });

        // Update last_active timestamp in database
        // Fire-and-forget API call (no await needed)
        fetch(`/api/projects/${id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            // Only updating last_active, backend auto-updates it
          }),
        }).catch((error) => {
          console.error('[Project Store] Failed to update last_active:', error);
        });
      },

      /**
       * Load projects into store (typically from API on app initialization)
       */
      loadProjects: (projects) => {
        set({ projects });
      },

      /**
       * Add a new project to the beginning of the list and set as active
       */
      addProject: (project) => {
        set((state) => ({
          projects: [project, ...state.projects],
          activeProjectId: project.id,
        }));
      },

      /**
       * Update an existing project in the list
       */
      updateProject: (id, updates) => {
        set((state) => ({
          projects: state.projects.map((p) =>
            p.id === id ? { ...p, ...updates } : p
          ),
        }));
      },

      /**
       * Remove a project from the list
       */
      removeProject: (id) => {
        set((state) => ({
          projects: state.projects.filter((p) => p.id !== id),
          activeProjectId: state.activeProjectId === id ? null : state.activeProjectId,
        }));
      },
    }),
    {
      name: 'bmad-project-storage', // localStorage key
      version: 1,
      // Only persist activeProjectId (not full projects array)
      partialize: (state) => ({
        activeProjectId: state.activeProjectId,
      }),
    }
  )
);
]]></code>
    </artifact>

    <!-- SuggestionCard Component -->
    <artifact name="SuggestionCard.tsx" path="src/components/features/curation/SuggestionCard.tsx">
      <description>Current suggestion card component to be modified with selection support</description>
      <code><![CDATA[
/**
 * SuggestionCard Component - Epic 4, Story 4.2
 */

import * as React from 'react';
import Image from 'next/image';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { type VisualSuggestion } from '@/types/visual-suggestions';
import {
  User,
  Clock,
  Download,
  CheckCircle,
  AlertCircle,
  Video,
} from 'lucide-react';

/**
 * Props for SuggestionCard component
 */
interface SuggestionCardProps {
  suggestion: VisualSuggestion;
  className?: string;
  onClick?: () => void;
}

/**
 * Format duration from seconds to MM:SS format
 */
function formatDuration(seconds: number | undefined): string {
  if (!seconds || seconds === 0) {
    return '--:--';
  }

  const minutes = Math.floor(seconds / 60);
  const remainingSeconds = Math.floor(seconds % 60);
  return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

/**
 * Get download status badge configuration
 */
function getDownloadStatusBadge(status: VisualSuggestion['downloadStatus']) {
  switch (status) {
    case 'pending':
      return {
        variant: 'outline' as const,
        icon: Clock,
        text: 'Queued',
        className: 'text-slate-600 dark:text-slate-400',
      };
    case 'downloading':
      return {
        variant: 'info' as const,
        icon: Download,
        text: 'Downloading...',
        className: 'animate-pulse',
      };
    case 'complete':
      return {
        variant: 'success' as const,
        icon: CheckCircle,
        text: 'Ready',
        className: '',
      };
    case 'error':
      return {
        variant: 'error' as const,
        icon: AlertCircle,
        text: 'Failed',
        className: '',
      };
    default:
      return {
        variant: 'outline' as const,
        icon: Clock,
        text: 'Pending',
        className: '',
      };
  }
}

/**
 * SuggestionCard Component
 */
export function SuggestionCard({ suggestion, className, onClick }: SuggestionCardProps) {
  const [thumbnailError, setThumbnailError] = React.useState(false);
  const statusBadge = getDownloadStatusBadge(suggestion.downloadStatus);
  const StatusIcon = statusBadge.icon;

  return (
    <Card
      className={`relative overflow-hidden transition-all hover:shadow-lg hover:border-blue-400 dark:hover:border-blue-600 cursor-pointer ${className || ''}`}
      onClick={onClick}
      role="button"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          onClick?.();
        }
      }}
      aria-label={`Preview video: ${suggestion.title} by ${suggestion.channelTitle}`}
    >
      {/* Rank Badge - Top Left */}
      <div className="absolute top-2 left-2 z-10">
        <Badge
          variant="default"
          className="bg-blue-600 text-white font-bold shadow-md"
        >
          #{suggestion.rank}
        </Badge>
      </div>

      {/* Download Status Badge - Top Right */}
      <div className="absolute top-2 right-2 z-10">
        <Badge variant={statusBadge.variant} className={statusBadge.className}>
          <StatusIcon className="w-3 h-3 mr-1" />
          {statusBadge.text}
        </Badge>
      </div>

      <CardContent className="p-0">
        {/* Thumbnail */}
        <div className="relative w-full aspect-video bg-slate-200 dark:bg-slate-800">
          {!thumbnailError ? (
            <Image
              src={suggestion.thumbnailUrl}
              alt={suggestion.title}
              fill
              className="object-cover"
              onError={() => setThumbnailError(true)}
              unoptimized
            />
          ) : (
            <div className="absolute inset-0 flex items-center justify-center bg-slate-200 dark:bg-slate-800">
              <Video className="w-12 h-12 text-slate-400 dark:text-slate-600" />
            </div>
          )}
        </div>

        {/* Metadata */}
        <div className="p-3 space-y-2">
          {/* Video Title */}
          <h3
            className="text-sm font-semibold text-slate-900 dark:text-slate-100 line-clamp-2 leading-tight"
            title={suggestion.title}
          >
            {suggestion.title}
          </h3>

          {/* Channel and Duration */}
          <div className="flex items-center justify-between gap-2 text-xs text-slate-600 dark:text-slate-400">
            {/* Channel */}
            <div className="flex items-center gap-1 min-w-0 flex-1">
              <User className="w-3 h-3 flex-shrink-0" />
              <span className="truncate" title={suggestion.channelTitle}>
                {suggestion.channelTitle}
              </span>
            </div>

            {/* Duration */}
            <div className="flex items-center gap-1 flex-shrink-0">
              <Clock className="w-3 h-3" />
              <span className="font-medium">{formatDuration(suggestion.duration)}</span>
            </div>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
]]></code>
    </artifact>

    <!-- VisualSuggestionGallery Component -->
    <artifact name="VisualSuggestionGallery.tsx" path="src/components/features/curation/VisualSuggestionGallery.tsx">
      <description>Current gallery component to be modified with selection integration</description>
      <code><![CDATA[
/**
 * VisualSuggestionGallery Component - Epic 4, Story 4.2
 */

'use client';

import * as React from 'react';
import { type VisualSuggestion } from '@/types/visual-suggestions';
import { SuggestionCard } from './SuggestionCard';
import { EmptyClipState } from './EmptyClipState';
import { Skeleton } from '@/components/ui/skeleton';
import { Button } from '@/components/ui/button';
import { AlertCircle } from 'lucide-react';

/**
 * Props for VisualSuggestionGallery component
 */
interface VisualSuggestionGalleryProps {
  projectId: string;
  sceneId: string;
  sceneNumber: number;
  className?: string;
  onSuggestionClick?: (suggestion: VisualSuggestion) => void;
}

/**
 * API Response type for visual suggestions endpoint
 */
interface VisualSuggestionsApiResponse {
  suggestions: VisualSuggestion[];
  totalScenes: number;
  scenesWithSuggestions: number;
}

// ... LoadingSkeleton and ErrorState components ...

/**
 * VisualSuggestionGallery Component
 */
export function VisualSuggestionGallery({
  projectId,
  sceneId,
  sceneNumber,
  className,
  onSuggestionClick,
}: VisualSuggestionGalleryProps) {
  const [suggestions, setSuggestions] = React.useState<VisualSuggestion[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);

  /**
   * Fetch suggestions from API
   */
  const fetchSuggestions = React.useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `/api/projects/${projectId}/visual-suggestions?sceneId=${sceneId}`
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch suggestions: ${response.statusText}`);
      }

      const data: VisualSuggestionsApiResponse = await response.json();

      // Filter suggestions for this specific scene and sort by rank
      const sceneSuggestions = (data.suggestions || [])
        .filter((s) => s.sceneId === sceneId)
        .sort((a, b) => a.rank - b.rank);

      setSuggestions(sceneSuggestions);
    } catch (err) {
      console.error('[VisualSuggestionGallery] Error fetching suggestions:', err);
      setError(
        err instanceof Error
          ? err.message
          : 'Failed to load video suggestions. Please try again.'
      );
    } finally {
      setLoading(false);
    }
  }, [projectId, sceneId, sceneNumber]);

  // Fetch suggestions on mount
  React.useEffect(() => {
    fetchSuggestions();
  }, [fetchSuggestions]);

  return (
    <div className={className}>
      {/* Loading/Error/Empty states... */}

      {/* Suggestions Grid */}
      {!loading && !error && suggestions.length > 0 && (
        <div>
          <div className="mb-3">
            <h3 className="text-sm font-semibold text-slate-900 dark:text-slate-100">
              Suggested Video Clips ({suggestions.length})
            </h3>
          </div>

          <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
            {suggestions.map((suggestion) => (
              <SuggestionCard
                key={suggestion.id}
                suggestion={suggestion}
                onClick={() => onSuggestionClick?.(suggestion)}
              />
            ))}
          </div>
        </div>
      )}
    </div>
  );
}
]]></code>
    </artifact>

    <!-- VisualCurationClient Component -->
    <artifact name="VisualCurationClient.tsx" path="src/app/projects/[id]/visual-curation/VisualCurationClient.tsx">
      <description>Current curation client to be modified with selection counter and store initialization</description>
      <code><![CDATA[
/**
 * Visual Curation Client Component - Epic 4, Story 4.1
 */

'use client';

import * as React from 'react';
import { type Project, type Scene } from '@/lib/db/queries';
import { type VisualSuggestion } from '@/types/visual-suggestions';
import { SceneCard } from '@/components/features/curation/SceneCard';
import { VideoPreviewPlayer } from '@/components/features/curation/VideoPreviewPlayer';
import { Skeleton } from '@/components/ui/skeleton';
import { Button } from '@/components/ui/button';
import { Alert } from '@/components/ui/alert';
import {
  Dialog,
  DialogContent,
  DialogTitle,
} from '@/components/ui/dialog';

/**
 * Props for VisualCurationClient
 */
interface VisualCurationClientProps {
  project: Project;
}

/**
 * Visual Curation Client Component
 */
export function VisualCurationClient({ project }: VisualCurationClientProps) {
  const [scenes, setScenes] = React.useState<Scene[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [selectedSuggestion, setSelectedSuggestion] = React.useState<VisualSuggestion | null>(null);

  // Handle suggestion click - open preview
  const handleSuggestionClick = React.useCallback((suggestion: VisualSuggestion) => {
    setSelectedSuggestion(suggestion);
  }, []);

  // Handle closing preview
  const handleClosePreview = React.useCallback(() => {
    setSelectedSuggestion(null);
  }, []);

  /**
   * Fetch scenes from API
   */
  const fetchScenes = React.useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/projects/${project.id}/scenes`);
      const data = await response.json();

      if (!response.ok || !data.success) {
        throw new Error(data.error?.message || 'Failed to fetch scenes');
      }

      setScenes(data.data?.scenes || []);
    } catch (err) {
      console.error('Error fetching scenes:', err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred');
    } finally {
      setLoading(false);
    }
  }, [project.id]);

  // Fetch scenes on mount
  React.useEffect(() => {
    fetchScenes();
  }, [fetchScenes]);

  return (
    <div className="flex min-h-screen flex-col">
      {/* Header */}
      <header className="border-b bg-background dark:bg-slate-900 sticky top-0 z-10">
        <div className="container flex h-16 items-center gap-4 px-4 md:px-6 lg:px-8">
          <div className="flex-1">
            <h1 className="text-lg md:text-xl font-semibold text-slate-900 dark:text-slate-100">
              {project.name}
            </h1>
            <p className="text-xs md:text-sm text-slate-600 dark:text-slate-400">
              Visual Curation - Select clips for each scene
            </p>
          </div>
        </div>
      </header>

      {/* Main Content */}
      <main className="flex flex-1 flex-col p-4 md:p-6 lg:p-8 bg-slate-50 dark:bg-slate-950">
        <div className="max-w-4xl mx-auto w-full">
          {/* Loading/Error/Empty states and Scenes List */}
          {!loading && !error && scenes.length > 0 && (
            <div className="space-y-4 md:space-y-6">
              {/* Info banner and scene cards */}
            </div>
          )}
        </div>
      </main>

      {/* Video Preview Dialog */}
      <Dialog
        open={selectedSuggestion !== null}
        onOpenChange={(open) => {
          if (!open) {
            handleClosePreview();
          }
        }}
      >
        <DialogContent className="max-w-[800px] w-[95vw] p-6 bg-slate-800 border-slate-700">
          <DialogTitle className="sr-only">
            {selectedSuggestion?.title || 'Video Preview'}
          </DialogTitle>
          {selectedSuggestion && (
            <VideoPreviewPlayer
              suggestion={selectedSuggestion}
              projectId={project.id}
              onClose={handleClosePreview}
            />
          )}
        </DialogContent>
      </Dialog>
    </div>
  );
}
]]></code>
    </artifact>

    <!-- Scenes API Endpoint -->
    <artifact name="scenes/route.ts" path="src/app/api/projects/[id]/scenes/route.ts">
      <description>Reference API endpoint pattern for scenes retrieval</description>
      <code><![CDATA[
/**
 * Scenes API Endpoint - Epic 4, Story 4.1
 *
 * GET /api/projects/[id]/scenes - Retrieve all scenes for a project
 */

import { NextRequest, NextResponse } from 'next/server';
import { getProject, getScenesByProjectId, type Scene } from '@/lib/db/queries';
import { initializeDatabase } from '@/lib/db/init';

// Initialize database on first import (idempotent)
initializeDatabase();

/**
 * GET /api/projects/[id]/scenes
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params;

    // Validate project ID is provided
    if (!projectId) {
      return NextResponse.json(
        {
          success: false,
          error: {
            message: 'Project ID is required',
            code: 'INVALID_REQUEST',
          },
        },
        { status: 400 }
      );
    }

    // Verify project exists
    const project = getProject(projectId);
    if (!project) {
      return NextResponse.json(
        {
          success: false,
          error: {
            message: 'Project not found',
            code: 'NOT_FOUND',
          },
        },
        { status: 404 }
      );
    }

    // Fetch scenes ordered by scene_number ASC
    const scenes = getScenesByProjectId(projectId);

    return NextResponse.json(
      {
        success: true,
        data: { scenes },
      },
      { status: 200 }
    );
  } catch (error) {
    console.error('[API Error] GET /api/projects/[id]/scenes:', error);
    return NextResponse.json(
      {
        success: false,
        error: {
          message: 'Failed to fetch scenes',
          code: 'DATABASE_ERROR',
        },
      },
      { status: 500 }
    );
  }
}
]]></code>
    </artifact>

    <!-- Visual Suggestions API Endpoint -->
    <artifact name="visual-suggestions/route.ts" path="src/app/api/projects/[id]/visual-suggestions/route.ts">
      <description>Reference API endpoint pattern for visual suggestions</description>
      <code><![CDATA[
/**
 * Visual Suggestions Retrieval API Endpoint
 *
 * GET /api/projects/[id]/visual-suggestions - Retrieve visual suggestions for a project
 */

import { NextRequest, NextResponse } from 'next/server';
import {
  getProject,
  getVisualSuggestions,
  getVisualSuggestionsByProject,
  getScenesCount,
  getScenesWithSuggestionsCount
} from '@/lib/db/queries';
import { initializeDatabase } from '@/lib/db/init';

// Initialize database on first import (idempotent)
await initializeDatabase();

/**
 * GET /api/projects/[id]/visual-suggestions
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params;

    // Validate project exists
    const project = getProject(projectId);
    if (!project) {
      return NextResponse.json(
        { success: false, error: 'Project not found', code: 'PROJECT_NOT_FOUND' },
        { status: 404 }
      );
    }

    // Check for optional sceneId query parameter
    const { searchParams } = new URL(request.url);
    const sceneId = searchParams.get('sceneId');

    let suggestions;

    if (sceneId) {
      suggestions = getVisualSuggestions(sceneId);
    } else {
      suggestions = getVisualSuggestionsByProject(projectId);
    }

    const totalScenes = getScenesCount(projectId);
    const scenesWithSuggestions = getScenesWithSuggestionsCount(projectId);

    return NextResponse.json(
      {
        suggestions,
        totalScenes,
        scenesWithSuggestions
      },
      { status: 200 }
    );
  } catch (error: any) {
    console.error('[Visual Suggestions] Error:', error);

    return NextResponse.json(
      {
        success: false,
        error: error.message || 'An unexpected error occurred',
        code: 'INTERNAL_ERROR'
      },
      { status: 500 }
    );
  }
}
]]></code>
    </artifact>

    <!-- Migration Pattern Reference -->
    <artifact name="migrations/003_visual_suggestions_schema.ts" path="src/lib/db/migrations/003_visual_suggestions_schema.ts">
      <description>Reference migration pattern to follow</description>
      <code><![CDATA[
/**
 * Migration 003: Visual Suggestions Schema
 */

import type { Database } from 'better-sqlite3';

/**
 * Apply migration: Add Epic 3 schema changes
 */
export function up(db: Database): void {
  console.log('Running migration 003: Visual Suggestions Schema');

  // Start transaction for atomicity
  const transaction = db.transaction(() => {
    // Check if column already exists to ensure idempotency
    const tableInfo = db.pragma('table_info(projects)') as Array<{ name: string }>;
    const existingColumns = new Set(tableInfo.map((col) => col.name));

    // 1. Add visuals_generated column to projects table
    if (!existingColumns.has('visuals_generated')) {
      db.exec('ALTER TABLE projects ADD COLUMN visuals_generated BOOLEAN DEFAULT 0');
      console.log('  - Added visuals_generated column to projects');
    }

    // 2. Create visual_suggestions table (IF NOT EXISTS for idempotency)
    db.exec(`
      CREATE TABLE IF NOT EXISTS visual_suggestions (
        id TEXT PRIMARY KEY,
        scene_id TEXT NOT NULL,
        video_id TEXT NOT NULL,
        title TEXT NOT NULL,
        thumbnail_url TEXT,
        channel_title TEXT,
        embed_url TEXT NOT NULL,
        rank INTEGER NOT NULL,
        duration INTEGER,
        default_segment_path TEXT,
        download_status TEXT DEFAULT 'pending' CHECK(download_status IN ('pending', 'downloading', 'complete', 'error')),
        created_at TEXT DEFAULT (datetime('now')),
        FOREIGN KEY (scene_id) REFERENCES scenes(id) ON DELETE CASCADE,
        UNIQUE(scene_id, video_id)
      )
    `);

    // 3. Create index on scene_id
    db.exec('CREATE INDEX IF NOT EXISTS idx_visual_suggestions_scene ON visual_suggestions(scene_id)');
  });

  // Execute transaction
  transaction();

  console.log('Migration 003 completed successfully');
}

/**
 * Rollback migration
 */
export function down(db: Database): void {
  // Rollback logic...
}
]]></code>
    </artifact>

    <!-- Toast Hook -->
    <artifact name="use-toast.ts" path="src/hooks/use-toast.ts">
      <description>Toast notification hook for success/error feedback</description>
      <code><![CDATA[
import * as React from "react"

type ToasterToast = {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: React.ReactNode
  variant?: "default" | "destructive"
}

// ... reducer and state management ...

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = Math.random().toString(36).substr(2, 9)

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
]]></code>
    </artifact>

    <!-- cn Utility -->
    <artifact name="cn.ts" path="src/lib/utils/cn.ts">
      <description>Tailwind class merge utility</description>
      <code><![CDATA[
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merge Tailwind CSS classes with proper conflict resolution
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
]]></code>
    </artifact>
  </existing-code>

  <!-- ============================================== -->
  <!-- TYPE DEFINITIONS -->
  <!-- ============================================== -->
  <type-definitions>
    <!-- Existing Scene Interface -->
    <type name="Scene" path="src/lib/db/queries.ts">
      <definition><![CDATA[
export interface Scene {
  id: string;
  project_id: string;
  scene_number: number;
  text: string;
  sanitized_text: string | null;
  audio_file_path: string | null;
  duration: number | null;
  created_at: string;
  updated_at: string;
  // TO ADD in Story 4.4:
  // selected_clip_id: string | null;
}
]]></definition>
    </type>

    <!-- Existing VisualSuggestion Interface -->
    <type name="VisualSuggestion" path="src/types/visual-suggestions.ts">
      <definition><![CDATA[
export interface VisualSuggestion {
  id: string;
  sceneId: string;
  videoId: string;
  title: string;
  thumbnailUrl: string;
  channelTitle: string;
  embedUrl: string;
  rank: number;
  duration?: number;
  defaultSegmentPath?: string;
  downloadStatus: DownloadStatus;
  createdAt: string;
}

export type DownloadStatus = 'pending' | 'downloading' | 'complete' | 'error';
]]></definition>
    </type>

    <!-- New ClipSelection Interface -->
    <type name="ClipSelection" path="src/lib/stores/curation-store.ts (TO CREATE)">
      <definition><![CDATA[
interface ClipSelection {
  sceneId: string;
  suggestionId: string;
  videoId: string;
}
]]></definition>
    </type>

    <!-- New CurationState Interface -->
    <type name="CurationState" path="src/lib/stores/curation-store.ts (TO CREATE)">
      <definition><![CDATA[
interface CurationState {
  projectId: string | null;
  selections: Map<string, ClipSelection>; // sceneId -> ClipSelection
  totalScenes: number;

  // Actions
  setProject: (projectId: string) => void;
  setTotalScenes: (count: number) => void;
  selectClip: (sceneId: string, suggestionId: string, videoId: string) => void;
  clearSelection: (sceneId: string) => void;
  loadSelections: (selections: ClipSelection[]) => void;
  isSceneComplete: (sceneId: string) => boolean;
  getSelectionCount: () => number;
  getAllSelected: () => boolean;
  reset: () => void;
}
]]></definition>
    </type>
  </type-definitions>

  <!-- ============================================== -->
  <!-- DATABASE SCHEMA -->
  <!-- ============================================== -->
  <database-schema>
    <table name="scenes" description="Scenes table - requires selected_clip_id column addition">
      <current-schema><![CDATA[
CREATE TABLE scenes (
  id TEXT PRIMARY KEY,
  project_id TEXT NOT NULL,
  scene_number INTEGER NOT NULL,
  text TEXT NOT NULL,
  sanitized_text TEXT,
  audio_file_path TEXT,
  duration REAL,
  created_at TEXT DEFAULT (datetime('now')),
  updated_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (project_id) REFERENCES projects(id) ON DELETE CASCADE,
  UNIQUE(project_id, scene_number)
);

-- Existing indexes
CREATE INDEX idx_scenes_project ON scenes(project_id);
CREATE INDEX idx_scenes_number ON scenes(scene_number);
]]></current-schema>

      <required-changes><![CDATA[
-- Migration 006: Add selected_clip_id to scenes table
ALTER TABLE scenes ADD COLUMN selected_clip_id TEXT;

-- Note: SQLite does not support adding FK constraints via ALTER TABLE
-- The foreign key relationship (scenes.selected_clip_id -> visual_suggestions.id)
-- is enforced at application level in the API endpoint validation

-- Create index for performance
CREATE INDEX IF NOT EXISTS idx_scenes_selected_clip ON scenes(selected_clip_id);
]]></required-changes>
    </table>

    <table name="visual_suggestions" description="Visual suggestions table - used as foreign key reference">
      <schema><![CDATA[
CREATE TABLE visual_suggestions (
  id TEXT PRIMARY KEY,
  scene_id TEXT NOT NULL,
  video_id TEXT NOT NULL,
  title TEXT NOT NULL,
  thumbnail_url TEXT,
  channel_title TEXT,
  embed_url TEXT NOT NULL,
  rank INTEGER NOT NULL,
  duration INTEGER,
  default_segment_path TEXT,
  download_status TEXT DEFAULT 'pending' CHECK(download_status IN ('pending', 'downloading', 'complete', 'error')),
  created_at TEXT DEFAULT (datetime('now')),
  FOREIGN KEY (scene_id) REFERENCES scenes(id) ON DELETE CASCADE,
  UNIQUE(scene_id, video_id)
);

CREATE INDEX idx_visual_suggestions_scene ON visual_suggestions(scene_id);
]]></schema>
    </table>
  </database-schema>

  <!-- ============================================== -->
  <!-- IMPLEMENTATION PATTERNS -->
  <!-- ============================================== -->
  <implementation-patterns>
    <pattern name="Zustand Store with Map and Custom Storage">
      <description>Pattern for handling Map serialization in Zustand persist middleware</description>
      <code><![CDATA[
export const useCurationStore = create<CurationState>()(
  persist(
    (set, get) => ({
      projectId: null,
      selections: new Map(),
      totalScenes: 0,

      setProject: (projectId) => set({ projectId }),

      setTotalScenes: (count) => set({ totalScenes: count }),

      selectClip: (sceneId, suggestionId, videoId) => {
        // Optimistic UI update
        set((state) => {
          const newSelections = new Map(state.selections);
          newSelections.set(sceneId, { sceneId, suggestionId, videoId });
          return { selections: newSelections };
        });

        // Save to database asynchronously
        const projectId = get().projectId;
        if (projectId) {
          saveClipSelection(projectId, sceneId, suggestionId).catch((error) => {
            // Revert on error
            set((state) => {
              const newSelections = new Map(state.selections);
              newSelections.delete(sceneId);
              return { selections: newSelections };
            });
            // Error notification handled by component
          });
        }
      },

      // ... other actions
    }),
    {
      name: 'curation-storage',
      storage: {
        getItem: (name) => {
          const str = localStorage.getItem(name);
          if (!str) return null;
          const parsed = JSON.parse(str);
          // Convert selections array back to Map
          if (parsed.state.selections) {
            parsed.state.selections = new Map(parsed.state.selections);
          }
          return parsed;
        },
        setItem: (name, value) => {
          // Convert Map to array for JSON serialization
          const toStore = {
            ...value,
            state: {
              ...value.state,
              selections: Array.from(value.state.selections.entries()),
            },
          };
          localStorage.setItem(name, JSON.stringify(toStore));
        },
        removeItem: (name) => localStorage.removeItem(name),
      },
    }
  )
);

// Helper function for API call
async function saveClipSelection(
  projectId: string,
  sceneId: string,
  suggestionId: string
): Promise<void> {
  const response = await fetch(`/api/projects/${projectId}/select-clip`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sceneId, suggestionId }),
  });
  if (!response.ok) {
    throw new Error('Failed to save selection');
  }
}
]]></code>
    </pattern>

    <pattern name="Visual Selection Indicators">
      <description>Tailwind classes for selected state on SuggestionCard</description>
      <code><![CDATA[
// Conditional styling based on isSelected prop
<Card
  className={cn(
    "relative cursor-pointer transition-all duration-200",
    isSelected
      ? "border-indigo-500 border-2 shadow-lg shadow-indigo-500/20"
      : "border-slate-700 hover:border-slate-500",
    className
  )}
  onClick={onSelect}
>
  {/* Selection checkmark indicator */}
  {isSelected && (
    <div className="absolute top-2 right-2 bg-indigo-500 rounded-full p-1 z-20">
      <Check className="h-4 w-4 text-white" />
    </div>
  )}

  {/* ... existing card content ... */}

  {/* Selected badge at bottom */}
  {isSelected && (
    <Badge className="mt-2 bg-indigo-500 text-white">
      Selected
    </Badge>
  )}
</Card>
]]></code>
    </pattern>

    <pattern name="Click Area Separation">
      <description>Separate selection click from preview click</description>
      <code><![CDATA[
// Card body click = select, Play button click = preview
<Card onClick={onSelect}>
  {/* ... card content ... */}

  {/* Preview button with click propagation stopped */}
  <button
    className="absolute bottom-2 right-2 bg-black/50 rounded-full p-2 hover:bg-black/70"
    onClick={(e) => {
      e.stopPropagation();
      onClick?.(); // Preview handler
    }}
    aria-label="Preview video"
  >
    <Play className="h-4 w-4 text-white" />
  </button>
</Card>
]]></code>
    </pattern>

    <pattern name="Selection Progress Counter">
      <description>Display selection count in page header</description>
      <code><![CDATA[
// In VisualCurationClient header
const { selections, totalScenes } = useCurationStore();
const selectionCount = selections.size;

<div className="flex items-center gap-2 text-sm text-slate-400">
  <span>Scenes Selected:</span>
  <span className="font-semibold text-white">
    {selectionCount}/{totalScenes}
  </span>
  {selectionCount === totalScenes && (
    <CheckCircle className="h-4 w-4 text-green-500" />
  )}
</div>
]]></code>
    </pattern>

    <pattern name="Toast Notification on Selection">
      <description>Success and error toast patterns</description>
      <code><![CDATA[
import { useToast } from '@/hooks/use-toast';

// In component
const { toast } = useToast();

const handleSelectClip = async (suggestion: VisualSuggestion) => {
  try {
    selectClip(sceneId, suggestion.id, suggestion.videoId);
    toast({
      title: "Clip Selected",
      description: `Selected "${suggestion.title}" for Scene ${sceneNumber}`,
    });
  } catch (error) {
    toast({
      variant: "destructive",
      title: "Selection Failed",
      description: "Failed to save selection. Please try again.",
    });
  }
};
]]></code>
    </pattern>

    <pattern name="API POST Endpoint Pattern">
      <description>Pattern for POST /api/projects/[id]/select-clip</description>
      <code><![CDATA[
import { NextRequest, NextResponse } from 'next/server';
import { getProject, getScenesByProjectId } from '@/lib/db/queries';
import { getDb } from '@/lib/db/client';
import { initializeDatabase } from '@/lib/db/init';

initializeDatabase();

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: projectId } = await params;
    const { sceneId, suggestionId } = await request.json();

    // Validate required fields
    if (!sceneId || !suggestionId) {
      return NextResponse.json(
        { error: 'sceneId and suggestionId are required' },
        { status: 400 }
      );
    }

    const db = getDb();

    // Validate scene belongs to project
    const scene = db.prepare(`
      SELECT id FROM scenes WHERE id = ? AND project_id = ?
    `).get(sceneId, projectId);

    if (!scene) {
      return NextResponse.json(
        { error: 'Scene not found in project' },
        { status: 400 }
      );
    }

    // Validate suggestion belongs to scene
    const suggestion = db.prepare(`
      SELECT id FROM visual_suggestions WHERE id = ? AND scene_id = ?
    `).get(suggestionId, sceneId);

    if (!suggestion) {
      return NextResponse.json(
        { error: 'Suggestion does not belong to specified scene' },
        { status: 409 }
      );
    }

    // Update scenes table with selected_clip_id
    db.prepare(`
      UPDATE scenes
      SET selected_clip_id = ?
      WHERE id = ?
    `).run(suggestionId, sceneId);

    return NextResponse.json({
      success: true,
      sceneId,
      selectedClipId: suggestionId,
    });
  } catch (error) {
    console.error('[API Error] POST /api/projects/[id]/select-clip:', error);
    return NextResponse.json(
      { error: 'Failed to save selection' },
      { status: 500 }
    );
  }
}
]]></code>
    </pattern>
  </implementation-patterns>

  <!-- ============================================== -->
  <!-- TESTING REQUIREMENTS -->
  <!-- ============================================== -->
  <testing-requirements>
    <unit-tests>
      <test-file path="tests/stores/curation-store.test.ts">
        <test-case>selectClip adds selection to Map</test-case>
        <test-case>selectClip replaces previous selection for same scene</test-case>
        <test-case>clearSelection removes selection</test-case>
        <test-case>isSceneComplete returns correct boolean</test-case>
        <test-case>getSelectionCount returns accurate count</test-case>
        <test-case>getAllSelected returns true when all scenes selected</test-case>
        <test-case>localStorage persistence serializes/deserializes Map</test-case>
        <test-case>reset clears all state</test-case>
        <test-case>loadSelections populates Map from array</test-case>
      </test-file>
    </unit-tests>

    <api-tests>
      <test-file path="tests/api/select-clip.test.ts">
        <test-case>POST returns 200 with valid sceneId and suggestionId</test-case>
        <test-case>POST returns 400 for missing sceneId</test-case>
        <test-case>POST returns 400 for missing suggestionId</test-case>
        <test-case>POST returns 400 for invalid sceneId (not in project)</test-case>
        <test-case>POST returns 409 for suggestionId not belonging to scene</test-case>
        <test-case>Database is updated with selected_clip_id</test-case>
        <test-case>Response format matches specification</test-case>
      </test-file>
    </api-tests>

    <integration-tests>
      <test-case>Clicking suggestion card triggers selection in store</test-case>
      <test-case>Visual indicator appears on selected card</test-case>
      <test-case>Selecting different clip deselects previous</test-case>
      <test-case>Selection counter updates in real-time</test-case>
      <test-case>Selections persist after page refresh</test-case>
      <test-case>Existing database selections load on mount</test-case>
      <test-case>Error handling with mocked API failure</test-case>
      <test-case>Toast notifications appear correctly</test-case>
      <test-case>Preview button still works separately from selection</test-case>
    </integration-tests>
  </testing-requirements>

  <!-- ============================================== -->
  <!-- IMPLEMENTATION CHECKLIST -->
  <!-- ============================================== -->
  <implementation-checklist>
    <task id="1" ac="9">Create Database Migration for selected_clip_id
      <subtask>Create migration 006 in src/lib/db/migrations/</subtask>
      <subtask>Add SQL: ALTER TABLE scenes ADD COLUMN selected_clip_id TEXT</subtask>
      <subtask>Create index on selected_clip_id for performance</subtask>
      <subtask>Test migration runs successfully</subtask>
      <subtask>Register migration in init.ts</subtask>
    </task>

    <task id="2" ac="1,2,3,6">Create Curation Store (Zustand)
      <subtask>Create file: src/lib/stores/curation-store.ts</subtask>
      <subtask>Define ClipSelection interface</subtask>
      <subtask>Define CurationState interface</subtask>
      <subtask>Implement Zustand store with persist middleware</subtask>
      <subtask>Implement custom storage for Map serialization</subtask>
      <subtask>Implement selectClip action with optimistic update</subtask>
      <subtask>Add saveClipSelection helper function</subtask>
      <subtask>Export useCurationStore hook</subtask>
    </task>

    <task id="3" ac="4">Create POST /api/projects/[id]/select-clip Endpoint
      <subtask>Create file: src/app/api/projects/[id]/select-clip/route.ts</subtask>
      <subtask>Implement POST handler with request validation</subtask>
      <subtask>Validate scene belongs to project</subtask>
      <subtask>Validate suggestion belongs to scene</subtask>
      <subtask>Update scenes.selected_clip_id in database</subtask>
      <subtask>Return appropriate status codes (200, 400, 409, 500)</subtask>
    </task>

    <task id="4" ac="1,8">Add Visual Selection Indicators to SuggestionCard
      <subtask>Add isSelected and onSelect props to interface</subtask>
      <subtask>Import Check icon from lucide-react</subtask>
      <subtask>Add conditional border/shadow styling</subtask>
      <subtask>Add checkmark indicator when selected</subtask>
      <subtask>Add "Selected" badge</subtask>
      <subtask>Separate selection click from preview click</subtask>
    </task>

    <task id="5" ac="1,2,3,6,7">Integrate Selection Logic in VisualSuggestionGallery
      <subtask>Import useCurationStore hook</subtask>
      <subtask>Get current selection state for scene</subtask>
      <subtask>Pass isSelected prop to SuggestionCard</subtask>
      <subtask>Implement handleSelectClip with toast</subtask>
      <subtask>Handle error state reversion</subtask>
    </task>

    <task id="6" ac="5">Add Selection Progress Counter
      <subtask>Update VisualCurationClient.tsx</subtask>
      <subtask>Import useCurationStore</subtask>
      <subtask>Initialize store with project data on mount</subtask>
      <subtask>Add counter display in header</subtask>
      <subtask>Add CheckCircle when all selected</subtask>
    </task>

    <task id="7" ac="3">Load Existing Selections on Page Mount
      <subtask>Update Scene interface with selected_clip_id</subtask>
      <subtask>Update getScenesByProjectId query</subtask>
      <subtask>Load selections into store from database</subtask>
      <subtask>Handle priority: database &gt; localStorage</subtask>
    </task>

    <task id="8" ac="7">Implement Error Handling and UI Reversion
      <subtask>Add error callback to store</subtask>
      <subtask>Implement UI state reversion</subtask>
      <subtask>Add toast error notification</subtask>
      <subtask>Log errors for debugging</subtask>
    </task>

    <task id="9" ac="1">Add Click Area Separation
      <subtask>Card body click triggers selection</subtask>
      <subtask>Preview button with stopPropagation</subtask>
      <subtask>Add Play icon for preview action</subtask>
    </task>

    <task id="10">Unit Testing
      <subtask>Create tests/stores/curation-store.test.ts</subtask>
      <subtask>Test all store actions</subtask>
      <subtask>Test Map operations</subtask>
      <subtask>Test localStorage persistence</subtask>
    </task>

    <task id="11">API Testing
      <subtask>Create tests/api/select-clip.test.ts</subtask>
      <subtask>Test all validation scenarios</subtask>
      <subtask>Test database updates</subtask>
      <subtask>Test response formats</subtask>
    </task>

    <task id="12">Integration Testing
      <subtask>Test complete selection flow</subtask>
      <subtask>Test error recovery</subtask>
      <subtask>Test persistence across refresh</subtask>
      <subtask>Test visual indicators</subtask>
    </task>
  </implementation-checklist>

  <!-- ============================================== -->
  <!-- REFERENCES -->
  <!-- ============================================== -->
  <references>
    <reference type="architecture" doc="docs/architecture.md" lines="1026-1134">Story 4.4 Zustand store and API</reference>
    <reference type="architecture" doc="docs/architecture.md" lines="2521-2531">scenes table with selected_clip_id</reference>
    <reference type="tech-spec" doc="docs/sprint-artifacts/tech-spec-epic-4.md" lines="207-225">POST /select-clip specification</reference>
    <reference type="tech-spec" doc="docs/sprint-artifacts/tech-spec-epic-4.md" lines="129-138">CurationState interface</reference>
    <reference type="prd" doc="docs/prd.md" lines="270-273">Feature 1.6 AC2 - Clip Selection</reference>
    <reference type="story" doc="docs/stories/story-4.1.md">Page structure patterns</reference>
    <reference type="story" doc="docs/stories/story-4.2.md">SuggestionCard component</reference>
    <reference type="story" doc="docs/stories/story-4.3.md">Preview functionality</reference>
  </references>
</story-context>
